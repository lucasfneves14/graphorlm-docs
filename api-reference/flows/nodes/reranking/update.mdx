---
title: 'Update Reranking Configuration'
description: 'Modify reranking node configurations in flows via the GraphorLM REST API'
---

Update the configuration of a specific reranking node within a flow in your GraphorLM project. This endpoint allows you to optimize the LLM-powered document reranking process by adjusting the number of top results returned, directly impacting the quality and performance of your RAG (Retrieval-Augmented Generation) system.

## Overview

The Update Reranking Configuration endpoint allows you to modify the configuration of reranking nodes within your flows. Reranking nodes use sophisticated Large Language Model scoring to intelligently reorder retrieved documents by relevance, and updating their configuration is essential for optimizing result quality, processing efficiency, and system performance.

- **Method**: `PATCH`
- **URL**: `https://{flow_name}.flows.graphorlm.com/reranking/{node_id}`
- **Authentication**: Required (API Token)

## Authentication

All requests must include a valid API token in the Authorization header:

```http
Authorization: Bearer YOUR_API_TOKEN
```

<Note>
Learn how to generate API tokens in the [API Tokens guide](/guides/api-tokens).
</Note>

## Request Format

### Headers

| Header | Value | Required |
|--------|-------|----------|
| `Authorization` | `Bearer YOUR_API_TOKEN` | Yes |
| `Content-Type` | `application/json` | Yes |

### URL Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `flow_name` | string | Yes | The name of the flow containing the reranking node |
| `node_id` | string | Yes | The unique identifier of the reranking node to update |

### Request Body

The request body should be a JSON object with the following structure:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `config` | object | Yes | The new configuration for the reranking node |

#### Config Object Structure

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `topK` | integer | No | Maximum number of documents to return after reranking (null for unlimited) |

### Example Request

```bash
PATCH https://my-rag-pipeline.flows.graphorlm.com/reranking/reranking-1748287628687
Authorization: Bearer YOUR_API_TOKEN
Content-Type: application/json

{
  "config": {
    "topK": 10
  }
}
```

## Response Format

### Success Response (200 OK)

```json
{
  "success": true,
  "message": "Reranking node 'reranking-1748287628687' updated successfully",
  "node_id": "reranking-1748287628687"
}
```

### Response Structure

| Field | Type | Description |
|-------|------|-------------|
| `success` | boolean | Whether the update was successful |
| `message` | string | Descriptive message about the update result |
| `node_id` | string | The ID of the updated reranking node |

## Code Examples

### JavaScript/Node.js

```javascript
async function updateRerankingNode(flowName, nodeId, config, apiToken) {
  const response = await fetch(`https://${flowName}.flows.graphorlm.com/reranking/${nodeId}`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      config: config
    })
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
}

// Usage examples

// 1. Set Top K for high-precision results
const precisionConfig = {
  topK: 5
};

updateRerankingNode('my-rag-pipeline', 'reranking-node-123', precisionConfig, 'YOUR_API_TOKEN')
  .then(result => {
    console.log('‚úÖ Reranking configured for high precision');
    console.log(`Message: ${result.message}`);
  })
  .catch(error => console.error('‚ùå Update failed:', error));

// 2. Set moderate Top K for balanced results
const balancedConfig = {
  topK: 15
};

updateRerankingNode('my-rag-pipeline', 'reranking-node-123', balancedConfig, 'YOUR_API_TOKEN')
  .then(result => {
    console.log('‚úÖ Reranking configured for balanced performance');
    console.log(`Updated node: ${result.node_id}`);
  })
  .catch(error => console.error('‚ùå Update failed:', error));

// 3. Remove Top K limit for unlimited results
const unlimitedConfig = {
  topK: null
};

updateRerankingNode('my-rag-pipeline', 'reranking-node-123', unlimitedConfig, 'YOUR_API_TOKEN')
  .then(result => {
    console.log('‚úÖ Reranking configured for unlimited results');
    console.log(`Success: ${result.success}`);
  })
  .catch(error => console.error('‚ùå Update failed:', error));
```

### Python

```python
import requests
import json

def update_reranking_node(flow_name, node_id, config, api_token):
    url = f"https://{flow_name}.flows.graphorlm.com/reranking/{node_id}"
    
    headers = {
        "Authorization": f"Bearer {api_token}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "config": config
    }
    
    response = requests.patch(url, headers=headers, json=payload)
    response.raise_for_status()
    
    return response.json()

def optimize_reranking_strategy(flow_name, node_id, api_token, strategy="balanced"):
    """
    Apply different reranking optimization strategies
    """
    
    optimization_configs = {
        "high_precision": {
            "topK": 5,
            "description": "Returns only the most relevant documents"
        },
        "precision": {
            "topK": 10,
            "description": "Good balance of quality and completeness"
        },
        "balanced": {
            "topK": 15,
            "description": "Balanced approach for most use cases"
        },
        "comprehensive": {
            "topK": 25,
            "description": "More comprehensive results with broader coverage"
        },
        "unlimited": {
            "topK": None,
            "description": "Process and return all retrieved documents"
        }
    }
    
    if strategy not in optimization_configs:
        raise ValueError(f"Unknown strategy: {strategy}")
    
    config_info = optimization_configs[strategy]
    config = {"topK": config_info["topK"]}
    
    try:
        result = update_reranking_node(flow_name, node_id, config, api_token)
        
        print(f"üîÑ Applied {strategy} reranking strategy")
        print(f"   Top K: {config['topK'] if config['topK'] is not None else 'Unlimited'}")
        print(f"   Description: {config_info['description']}")
        print(f"   Result: {result['message']}")
        
        return result
        
    except requests.exceptions.HTTPError as e:
        print(f"‚ùå Strategy application failed: {e}")
        if e.response.status_code == 404:
            print("   Node or flow not found")
        elif e.response.status_code == 400:
            print("   Invalid configuration parameters")
        raise

def batch_update_reranking_configs(flow_name, node_configs, api_token):
    """
    Update multiple reranking nodes with different configurations
    """
    results = []
    
    print(f"üîÑ Updating {len(node_configs)} reranking nodes...")
    
    for i, (node_id, config) in enumerate(node_configs.items(), 1):
        try:
            print(f"\n[{i}/{len(node_configs)}] Updating {node_id}...")
            
            result = update_reranking_node(flow_name, node_id, config, api_token)
            
            print(f"   ‚úÖ Success: {result['message']}")
            results.append({
                "node_id": node_id,
                "success": True,
                "result": result
            })
            
        except Exception as e:
            print(f"   ‚ùå Failed: {str(e)}")
            results.append({
                "node_id": node_id, 
                "success": False,
                "error": str(e)
            })
    
    # Summary
    successful = sum(1 for r in results if r["success"])
    failed = len(results) - successful
    
    print(f"\nüìä Batch Update Summary:")
    print(f"   ‚úÖ Successful: {successful}")
    print(f"   ‚ùå Failed: {failed}")
    
    return results

def analyze_reranking_impact(flow_name, node_id, api_token, test_topk_values=[5, 10, 15, 20]):
    """
    Test different Top K values to analyze their impact
    """
    print(f"üî¨ Analyzing reranking impact for different Top K values...")
    
    impact_analysis = {
        "node_id": node_id,
        "tested_values": [],
        "recommendations": []
    }
    
    for topk in test_topk_values:
        print(f"\nüìä Testing Top K = {topk}")
        
        try:
            # Apply configuration
            config = {"topK": topk}
            result = update_reranking_node(flow_name, node_id, config, api_token)
            
            analysis_result = {
                "topK": topk,
                "update_success": True,
                "performance_estimate": "high" if topk <= 10 else "medium" if topk <= 20 else "low",
                "quality_estimate": "high" if topk <= 15 else "medium",
                "use_case": get_topk_use_case(topk)
            }
            
            print(f"   ‚úÖ Configuration applied successfully")
            print(f"   üìà Performance estimate: {analysis_result['performance_estimate']}")
            print(f"   üéØ Quality estimate: {analysis_result['quality_estimate']}")
            print(f"   üí° Best for: {analysis_result['use_case']}")
            
        except Exception as e:
            analysis_result = {
                "topK": topk,
                "update_success": False,
                "error": str(e)
            }
            print(f"   ‚ùå Configuration failed: {e}")
        
        impact_analysis["tested_values"].append(analysis_result)
    
    # Generate recommendations
    successful_tests = [t for t in impact_analysis["tested_values"] if t.get("update_success")]
    
    if successful_tests:
        # Recommend based on performance and quality balance
        balanced_option = next((t for t in successful_tests if t["topK"] == 10), None)
        if balanced_option:
            impact_analysis["recommendations"].append("Top K = 10 provides optimal balance of quality and performance")
        
        # Recommend precision option
        precision_option = next((t for t in successful_tests if t["topK"] == 5), None)
        if precision_option:
            impact_analysis["recommendations"].append("Top K = 5 for maximum precision in critical applications")
        
        # Recommend comprehensive option
        comprehensive_option = next((t for t in successful_tests if t["topK"] >= 15), None)
        if comprehensive_option:
            impact_analysis["recommendations"].append(f"Top K = {comprehensive_option['topK']} for comprehensive coverage when recall is important")
    
    print(f"\nüí° Recommendations:")
    for rec in impact_analysis["recommendations"]:
        print(f"   ‚Ä¢ {rec}")
    
    return impact_analysis

def get_topk_use_case(topk):
    """Return the primary use case for a given Top K value"""
    if topk <= 5:
        return "High-precision applications, critical decisions"
    elif topk <= 10:
        return "General purpose, balanced quality-performance"
    elif topk <= 15:
        return "Comprehensive search, good coverage"
    elif topk <= 25:
        return "Research, exploratory analysis"
    else:
        return "Maximum coverage, research applications"

# Usage examples

try:
    # 1. Simple configuration update
    simple_config = {"topK": 10}
    
    result = update_reranking_node(
        "my-rag-pipeline", 
        "reranking-node-123", 
        simple_config, 
        "YOUR_API_TOKEN"
    )
    print(f"Update result: {result}")
    
    # 2. Apply optimization strategy
    optimize_reranking_strategy(
        "my-rag-pipeline",
        "reranking-node-123", 
        "YOUR_API_TOKEN",
        strategy="high_precision"
    )
    
    # 3. Batch update multiple nodes
    batch_configs = {
        "reranking-primary": {"topK": 10},
        "reranking-fallback": {"topK": 20},
        "reranking-research": {"topK": None}  # Unlimited
    }
    
    batch_results = batch_update_reranking_configs(
        "my-rag-pipeline",
        batch_configs,
        "YOUR_API_TOKEN"
    )
    
    # 4. Analyze impact of different configurations
    analyze_reranking_impact(
        "my-rag-pipeline",
        "reranking-node-123",
        "YOUR_API_TOKEN",
        test_topk_values=[5, 10, 15, 20]
    )

except Exception as e:
    print(f"Error: {e}")
```

### cURL

```bash
# Basic reranking configuration update
curl -X PATCH https://my-rag-pipeline.flows.graphorlm.com/reranking/reranking-node-123 \
  -H "Authorization: Bearer YOUR_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "config": {
      "topK": 10
    }
  }'

# High-precision configuration (fewer results)
curl -X PATCH https://my-rag-pipeline.flows.graphorlm.com/reranking/reranking-node-123 \
  -H "Authorization: Bearer YOUR_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "config": {
      "topK": 5
    }
  }'

# Comprehensive configuration (more results)
curl -X PATCH https://my-rag-pipeline.flows.graphorlm.com/reranking/reranking-node-123 \
  -H "Authorization: Bearer YOUR_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "config": {
      "topK": 25
    }
  }'

# Unlimited configuration (all results)
curl -X PATCH https://my-rag-pipeline.flows.graphorlm.com/reranking/reranking-node-123 \
  -H "Authorization: Bearer YOUR_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "config": {
      "topK": null
    }
  }'
```

### PHP

```php
<?php
function updateRerankingNode($flowName, $nodeId, $config, $apiToken) {
    $url = "https://{$flowName}.flows.graphorlm.com/reranking/{$nodeId}";
    
    $payload = json_encode([
        'config' => $config
    ]);
    
    $options = [
        'http' => [
            'header' => [
                "Authorization: Bearer {$apiToken}",
                "Content-Type: application/json"
            ],
            'method' => 'PATCH',
            'content' => $payload
        ]
    ];
    
    $context = stream_context_create($options);
    $result = file_get_contents($url, false, $context);
    
    if ($result === FALSE) {
        throw new Exception('Failed to update reranking node');
    }
    
    return json_decode($result, true);
}

function applyRerankingStrategy($flowName, $nodeId, $apiToken, $strategy = 'balanced') {
    $strategies = [
        'high_precision' => [
            'topK' => 5,
            'description' => 'Maximum precision for critical applications'
        ],
        'precision' => [
            'topK' => 10,
            'description' => 'High quality results with good performance'
        ],
        'balanced' => [
            'topK' => 15,
            'description' => 'Balanced approach for most use cases'
        ],
        'comprehensive' => [
            'topK' => 25,
            'description' => 'Comprehensive coverage for research'
        ],
        'unlimited' => [
            'topK' => null,
            'description' => 'Process all retrieved documents'
        ]
    ];
    
    if (!isset($strategies[$strategy])) {
        throw new Exception("Unknown strategy: {$strategy}");
    }
    
    $strategyConfig = $strategies[$strategy];
    $config = ['topK' => $strategyConfig['topK']];
    
    try {
        $result = updateRerankingNode($flowName, $nodeId, $config, $apiToken);
        
        echo "üîÑ Applied {$strategy} reranking strategy\n";
        echo "   Top K: " . ($config['topK'] ?? 'Unlimited') . "\n";
        echo "   Description: {$strategyConfig['description']}\n";
        echo "   Result: {$result['message']}\n";
        
        return $result;
        
    } catch (Exception $e) {
        echo "‚ùå Strategy application failed: " . $e->getMessage() . "\n";
        throw $e;
    }
}

function validateRerankingConfig($config) {
    $errors = [];
    $warnings = [];
    
    // Validate Top K
    if (isset($config['topK'])) {
        $topK = $config['topK'];
        
        if ($topK !== null) {
            if (!is_int($topK) || $topK <= 0) {
                $errors[] = 'topK must be a positive integer or null';
            } elseif ($topK > 100) {
                $warnings[] = 'Very high topK values may impact performance and resource usage';
            } elseif ($topK < 3) {
                $warnings[] = 'Very low topK values may limit result diversity';
            }
        }
    }
    
    return [
        'errors' => $errors,
        'warnings' => $warnings,
        'is_valid' => empty($errors)
    ];
}

function optimizeRerankingPerformance($flowName, $nodeId, $apiToken, $useCase = 'general') {
    $useCaseConfigs = [
        'critical' => [
            'topK' => 3,
            'rationale' => 'Maximum precision for critical decisions'
        ],
        'support' => [
            'topK' => 5,
            'rationale' => 'Focused results for customer support'
        ],
        'general' => [
            'topK' => 10,
            'rationale' => 'Balanced approach for general applications'
        ],
        'research' => [
            'topK' => 20,
            'rationale' => 'Comprehensive results for research'
        ],
        'exploration' => [
            'topK' => null,
            'rationale' => 'Unlimited results for exploratory analysis'
        ]
    ];
    
    if (!isset($useCaseConfigs[$useCase])) {
        throw new Exception("Unknown use case: {$useCase}");
    }
    
    $config = $useCaseConfigs[$useCase];
    
    echo "üéØ Optimizing reranking for '{$useCase}' use case\n";
    echo "   Configuration: Top K = " . ($config['topK'] ?? 'Unlimited') . "\n";
    echo "   Rationale: {$config['rationale']}\n";
    
    $rerankingConfig = ['topK' => $config['topK']];
    
    // Validate configuration
    $validation = validateRerankingConfig($rerankingConfig);
    
    if (!$validation['is_valid']) {
        echo "‚ùå Configuration validation failed:\n";
        foreach ($validation['errors'] as $error) {
            echo "   - {$error}\n";
        }
        return false;
    }
    
    // Show warnings
    foreach ($validation['warnings'] as $warning) {
        echo "‚ö†Ô∏è  Warning: {$warning}\n";
    }
    
    try {
        $result = updateRerankingNode($flowName, $nodeId, $rerankingConfig, $apiToken);
        echo "‚úÖ Optimization completed: {$result['message']}\n";
        return $result;
        
    } catch (Exception $e) {
        echo "‚ùå Optimization failed: " . $e->getMessage() . "\n";
        throw $e;
    }
}

// Usage examples
try {
    // 1. Simple update with validation
    $config = ['topK' => 10];
    
    $validation = validateRerankingConfig($config);
    if (!$validation['is_valid']) {
        echo "‚ùå Configuration errors:\n";
        foreach ($validation['errors'] as $error) {
            echo "   - {$error}\n";
        }
        exit(1);
    }
    
    $result = updateRerankingNode('my-rag-pipeline', 'reranking-node-123', $config, 'YOUR_API_TOKEN');
    echo "‚úÖ Configuration updated: " . $result['message'] . "\n";
    
    // 2. Apply strategy
    applyRerankingStrategy('my-rag-pipeline', 'reranking-node-123', 'YOUR_API_TOKEN', 'high_precision');
    
    // 3. Optimize for specific use case
    optimizeRerankingPerformance('my-rag-pipeline', 'reranking-node-123', 'YOUR_API_TOKEN', 'support');
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
}
?>
```

## Error Responses

### Common Error Codes

| Status Code | Description | Example Response |
|-------------|-------------|------------------|
| 400 | Bad Request - Invalid configuration parameters | `{"detail": "topK must be a positive integer or null"}` |
| 401 | Unauthorized - Invalid or missing API token | `{"detail": "Invalid authentication credentials"}` |
| 404 | Not Found - Flow or node not found | `{"detail": "Reranking node not found"}` |
| 422 | Unprocessable Entity - Validation error | `{"detail": "Invalid topK value"}` |
| 500 | Internal Server Error - Server error | `{"detail": "Failed to update reranking node"}` |

### Error Response Format

```json
{
  "detail": "Error message describing what went wrong"
}
```

### Example Error Responses

#### Invalid Configuration
```json
{
  "detail": "topK must be a positive integer or null"
}
```

#### Node Not Found
```json
{
  "detail": "Reranking node not found"
}
```

#### Invalid Top K Value
```json
{
  "detail": "topK must be greater than 0"
}
```

## Configuration Guidelines

### Top K Selection Strategy

#### High Precision (1-5)
- **Best for**: Critical decisions, high-stakes applications
- **Characteristics**: Maximum relevance, minimal noise
- **Trade-offs**: May miss some relevant results
- **Use cases**: Medical diagnosis, legal research, financial advice

```json
{
  "topK": 5
}
```

#### Balanced Performance (6-15)
- **Best for**: General applications, typical Q&A systems
- **Characteristics**: Good balance of quality and coverage
- **Trade-offs**: Optimal for most use cases
- **Use cases**: Customer support, knowledge bases, general search

```json
{
  "topK": 10
}
```

#### Comprehensive Coverage (16-30)
- **Best for**: Research, exploratory analysis
- **Characteristics**: Broader result set, better recall
- **Trade-offs**: May include less relevant results
- **Use cases**: Academic research, market analysis, comprehensive reviews

```json
{
  "topK": 25
}
```

#### Unlimited Processing
- **Best for**: Complete analysis, no result limits
- **Characteristics**: Process all retrieved documents
- **Trade-offs**: Higher resource usage and processing time
- **Use cases**: Research projects, complete document analysis

```json
{
  "topK": null
}
```

### Performance Considerations

#### Resource Optimization
- **Lower Top K**: Reduces LLM processing resource usage
- **Higher Top K**: Increases quality but requires more resources
- **Unlimited**: Maximum resource usage for complete analysis

#### Processing Time
- **Lower Top K**: Faster processing, quicker responses
- **Higher Top K**: Slower processing, more comprehensive results
- **Unlimited**: Longest processing time

#### Quality vs Efficiency
- **Quality Priority**: Use higher Top K values (15-25)
- **Efficiency Priority**: Use lower Top K values (5-10)
- **Balanced Approach**: Use moderate Top K values (10-15)

## Update Behavior

### Immediate Effects
- Configuration changes are applied instantly
- Node status changes to `updated: false` indicating reprocessing needed
- Previous results remain available until reprocessing

### Reprocessing Requirements
After configuration updates, you should:
1. **Re-run the flow** to apply new reranking settings
2. **Monitor quality impact** to validate configuration changes
3. **Adjust based on results** to optimize for your specific use case

### Best Practices for Updates
- **Test incrementally** with different Top K values
- **Monitor quality metrics** before and after changes
- **Consider resource implications** of higher Top K values
- **Document configuration rationale** for future reference

## Integration Examples

### Automated Quality Optimizer

```javascript
class RerankingQualityOptimizer {
  constructor(flowName, apiToken) {
    this.flowName = flowName;
    this.apiToken = apiToken;
    this.optimizationHistory = [];
  }

  async optimizeForUseCase(nodeId, useCase) {
    const strategies = {
      'customer_support': { topK: 5, rationale: 'Precise answers for customer queries' },
      'content_discovery': { topK: 15, rationale: 'Balanced discovery and relevance' },
      'research_analysis': { topK: 25, rationale: 'Comprehensive research coverage' },
      'critical_decisions': { topK: 3, rationale: 'Maximum precision for critical choices' },
      'exploratory_search': { topK: null, rationale: 'Complete analysis without limits' }
    };

    const strategy = strategies[useCase];
    if (!strategy) {
      throw new Error(`Unknown use case: ${useCase}`);
    }

    try {
      const result = await this.updateConfiguration(nodeId, { topK: strategy.topK });
      
      console.log(`üéØ Optimized for ${useCase}`);
      console.log(`Configuration: Top K = ${strategy.topK || 'Unlimited'}`);
      console.log(`Rationale: ${strategy.rationale}`);
      
      // Log optimization for tracking
      this.optimizationHistory.push({
        timestamp: new Date(),
        nodeId,
        useCase,
        topK: strategy.topK,
        rationale: strategy.rationale,
        result
      });
      
      return result;
    } catch (error) {
      console.error(`‚ùå Optimization failed: ${error.message}`);
      throw error;
    }
  }

  async updateConfiguration(nodeId, config) {
    const response = await fetch(`https://${this.flowName}.flows.graphorlm.com/reranking/${nodeId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${this.apiToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ config })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.json();
  }

  async performTopKAnalysis(nodeId, testValues = [3, 5, 10, 15, 20]) {
    console.log(`üî¨ Performing Top K analysis for node ${nodeId}`);
    const analysisResults = [];

    for (const topK of testValues) {
      try {
        console.log(`\nüìä Testing Top K = ${topK}`);
        
        const result = await this.updateConfiguration(nodeId, { topK });
        
        const analysis = {
          topK,
          success: true,
          resourceEstimate: this.estimateResourceUsage(topK),
          performanceEstimate: this.estimatePerformance(topK),
          qualityEstimate: this.estimateQuality(topK),
          recommendedFor: this.getRecommendation(topK)
        };
        
        console.log(`   ‚ö° Resources: ${analysis.resourceEstimate}`);
        console.log(`   ‚ö° Performance: ${analysis.performanceEstimate}`);
        console.log(`   üéØ Quality: ${analysis.qualityEstimate}`);
        console.log(`   üí° Recommended for: ${analysis.recommendedFor}`);
        
        analysisResults.push(analysis);
        
        // Small delay to avoid overwhelming the API
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        console.log(`   ‚ùå Failed: ${error.message}`);
        analysisResults.push({
          topK,
          success: false,
          error: error.message
        });
      }
    }

    this.generateAnalysisReport(analysisResults);
    return analysisResults;
  }

  estimateResourceUsage(topK) {
    if (topK === null) return 'Very High';
    if (topK <= 5) return 'Low';
    if (topK <= 15) return 'Medium';
    if (topK <= 25) return 'High';
    return 'Very High';
  }

  estimatePerformance(topK) {
    if (topK === null) return 'Slow';
    if (topK <= 5) return 'Fast';
    if (topK <= 15) return 'Good';
    if (topK <= 25) return 'Moderate';
    return 'Slow';
  }

  estimateQuality(topK) {
    if (topK === null) return 'Comprehensive';
    if (topK <= 3) return 'Precise';
    if (topK <= 10) return 'High';
    if (topK <= 20) return 'Good';
    return 'Comprehensive';
  }

  getRecommendation(topK) {
    if (topK === null) return 'Research and complete analysis';
    if (topK <= 3) return 'Critical decisions, high precision needs';
    if (topK <= 10) return 'General applications, balanced approach';
    if (topK <= 20) return 'Comprehensive search, research projects';
    return 'Exploratory analysis, broad coverage';
  }

  generateAnalysisReport(results) {
    console.log('\nüìã Top K Analysis Report');
    console.log('========================');
    
    const successful = results.filter(r => r.success);
    if (successful.length === 0) {
      console.log('‚ùå No successful configurations tested');
      return;
    }

    console.log(`‚úÖ Successfully tested ${successful.length} configurations\n`);
    
    // Find optimal configurations
    const lowResource = successful.filter(r => ['Low', 'Medium'].includes(r.resourceEstimate));
    const highPerformance = successful.filter(r => ['Fast', 'Good'].includes(r.performanceEstimate));
    const highQuality = successful.filter(r => ['High', 'Precise', 'Comprehensive'].includes(r.qualityEstimate));
    
    if (lowResource.length > 0) {
      const optimal = lowResource.find(r => highPerformance.includes(r) && highQuality.includes(r));
      if (optimal) {
        console.log(`üéØ Optimal Configuration: Top K = ${optimal.topK}`);
        console.log(`   Balances resource usage, performance, and quality\n`);
      }
    }
    
    // Specific recommendations
    console.log('üí° Specific Recommendations:');
    const precision = successful.find(r => r.topK <= 5);
    if (precision) {
      console.log(`   ‚Ä¢ For maximum precision: Top K = ${precision.topK}`);
    }
    
    const balanced = successful.find(r => r.topK >= 8 && r.topK <= 12);
    if (balanced) {
      console.log(`   ‚Ä¢ For balanced approach: Top K = ${balanced.topK}`);
    }
    
    const comprehensive = successful.find(r => r.topK >= 20);
    if (comprehensive) {
      console.log(`   ‚Ä¢ For comprehensive coverage: Top K = ${comprehensive.topK}`);
    }
  }

  getOptimizationHistory() {
    return this.optimizationHistory;
  }
}

// Usage
const optimizer = new RerankingQualityOptimizer('my-rag-pipeline', 'YOUR_API_TOKEN');

// Optimize for specific use case
optimizer.optimizeForUseCase('reranking-node-123', 'customer_support').catch(console.error);

// Perform comprehensive analysis
optimizer.performTopKAnalysis('reranking-node-123').catch(console.error);
```

### Configuration Validator and Recommender

```python
import requests
from typing import List, Dict, Any, Optional

class RerankingConfigValidator:
    def __init__(self, flow_name: str, api_token: str):
        self.flow_name = flow_name
        self.api_token = api_token
    
    def validate_config(self, config: dict) -> dict:
        """Validate reranking configuration and provide recommendations"""
        validation_result = {
            "is_valid": True,
            "errors": [],
            "warnings": [],
            "recommendations": [],
            "resource_analysis": {},
            "performance_analysis": {}
        }
        
        # Validate Top K
        top_k = config.get('topK')
        if top_k is not None:
            if not isinstance(top_k, int) or top_k <= 0:
                validation_result["errors"].append("topK must be a positive integer or null")
                validation_result["is_valid"] = False
            else:
                # Analyze Top K value
                if top_k == 1:
                    validation_result["warnings"].append("topK = 1 may be too restrictive for most use cases")
                elif top_k > 50:
                    validation_result["warnings"].append("topK > 50 may significantly impact performance and resource usage")
                elif top_k > 100:
                    validation_result["errors"].append("topK > 100 is not recommended due to performance constraints")
                    validation_result["is_valid"] = False
                
                # Resource analysis
                validation_result["resource_analysis"] = self._analyze_resource_usage(top_k)
                
                # Performance analysis  
                validation_result["performance_analysis"] = self._analyze_performance(top_k)
                
                # Generate recommendations
                validation_result["recommendations"] = self._generate_recommendations(top_k)
        
        return validation_result
    
    def _analyze_resource_usage(self, top_k: Optional[int]) -> dict:
        """Analyze resource usage implications of Top K setting"""
        if top_k is None:
            return {
                "level": "very_high",
                "description": "Unlimited processing - highest resource consumption",
                "relative_usage": "5x baseline"
            }
        elif top_k <= 5:
            return {
                "level": "low",
                "description": "Minimal resource consumption",
                "relative_usage": "1x baseline"
            }
        elif top_k <= 15:
            return {
                "level": "medium",
                "description": "Moderate resource consumption",
                "relative_usage": f"{top_k/5:.1f}x baseline"
            }
        elif top_k <= 30:
            return {
                "level": "high",
                "description": "High resource consumption",
                "relative_usage": f"{top_k/5:.1f}x baseline"
            }
        else:
            return {
                "level": "very_high",
                "description": "Very high resource consumption",
                "relative_usage": f"{top_k/5:.1f}x baseline"
            }
    
    def _analyze_performance(self, top_k: Optional[int]) -> dict:
        """Analyze performance implications of Top K setting"""
        if top_k is None:
            return {
                "speed": "slowest",
                "description": "Processes all documents - longest processing time",
                "estimated_time": "high"
            }
        elif top_k <= 5:
            return {
                "speed": "fastest",
                "description": "Minimal processing time",
                "estimated_time": "low"
            }
        elif top_k <= 15:
            return {
                "speed": "good",
                "description": "Balanced processing time",
                "estimated_time": "medium"
            }
        else:
            return {
                "speed": "slow",
                "description": "Extended processing time",
                "estimated_time": "high"
            }
    
    def _generate_recommendations(self, top_k: Optional[int]) -> List[str]:
        """Generate specific recommendations based on Top K value"""
        recommendations = []
        
        if top_k is None:
            recommendations.extend([
                "Consider setting a specific Top K limit to control resource usage",
                "Use unlimited only for comprehensive research applications",
                "Monitor processing time and resource usage closely"
            ])
        elif top_k <= 3:
            recommendations.extend([
                "Excellent for high-precision applications",
                "Consider increasing if result diversity is needed",
                "Ideal for critical decision-making scenarios"
            ])
        elif top_k <= 10:
            recommendations.extend([
                "Good balance of quality and performance",
                "Suitable for most general applications",
                "Consider A/B testing with slightly higher values"
            ])
        elif top_k <= 20:
            recommendations.extend([
                "Good for comprehensive coverage",
                "Monitor resource implications",
                "Consider if all results are actually needed"
            ])
        else:
            recommendations.extend([
                "Very high Top K - ensure this is necessary",
                "Consider breaking into multiple queries",
                "Monitor processing resource usage and time carefully"
            ])
        
        return recommendations
    
    async def update_with_validation(self, node_id: str, config: dict) -> dict:
        """Update reranking configuration after thorough validation"""
        
        # Validate configuration first
        validation = self.validate_config(config)
        
        if not validation["is_valid"]:
            raise ValueError(f"Invalid configuration: {'; '.join(validation['errors'])}")
        
        # Show warnings and recommendations
        for warning in validation["warnings"]:
            print(f"‚ö†Ô∏è  Warning: {warning}")
        
        print(f"\n‚ö° Resource Analysis:")
        resource = validation["resource_analysis"]
        print(f"   Level: {resource['level']}")
        print(f"   Impact: {resource['description']}")
        print(f"   Relative Usage: {resource['relative_usage']}")
        
        print(f"\n‚ö° Performance Analysis:")
        perf = validation["performance_analysis"]
        print(f"   Speed: {perf['speed']}")
        print(f"   Description: {perf['description']}")
        print(f"   Processing Time: {perf['estimated_time']}")
        
        print(f"\nüí° Recommendations:")
        for rec in validation["recommendations"]:
            print(f"   ‚Ä¢ {rec}")
        
        # Ask for confirmation if high impact
        top_k = config.get('topK')
        if top_k is None or top_k > 20:
            response = input(f"\n‚ö†Ô∏è  This configuration may have significant resource/performance impact. Continue? (y/N): ")
            if response.lower() != 'y':
                print("Configuration update cancelled.")
                return {"cancelled": True}
        
        # Proceed with update
        try:
            result = await self.update_reranking_node(node_id, config)
            print(f"‚úÖ Configuration updated successfully")
            return result
        except Exception as e:
            print(f"‚ùå Update failed: {e}")
            raise

    async def update_reranking_node(self, node_id: str, config: dict) -> dict:
        """Update reranking node configuration"""
        url = f"https://{self.flow_name}.flows.graphorlm.com/reranking/{node_id}"
        
        headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json"
        }
        
        payload = {"config": config}
        
        response = requests.patch(url, headers=headers, json=payload)
        response.raise_for_status()
        
        return response.json()

# Usage
validator = RerankingConfigValidator("my-rag-pipeline", "YOUR_API_TOKEN")

# Test different configurations
configs_to_test = [
    {"topK": 5},    # High precision
    {"topK": 10},   # Balanced
    {"topK": 25},   # Comprehensive
    {"topK": None}  # Unlimited
]

for config in configs_to_test:
    print(f"\nüîç Validating config: {config}")
    validation = validator.validate_config(config)
    
    if validation["is_valid"]:
        print("‚úÖ Configuration is valid")
        print(f"‚ö° Resources: {validation['resource_analysis']['level']}")
        print(f"‚ö° Performance: {validation['performance_analysis']['speed']}")
    else:
        print("‚ùå Configuration errors:", validation["errors"])
```

## Best Practices

### Configuration Management
- **Start Conservative**: Begin with lower Top K values (5-10) and adjust based on quality needs
- **Test Systematically**: Use A/B testing to compare different Top K values
- **Monitor Impact**: Track both quality improvements and resource implications
- **Document Rationale**: Keep records of configuration decisions and their outcomes

### Performance Optimization
- **Balance Quality vs Resources**: Higher Top K improves quality but increases resource usage
- **Consider Use Case**: Critical applications need fewer, higher-quality results
- **Monitor Processing Time**: Higher Top K values increase processing time
- **Plan for Scale**: Consider resource implications when scaling to high query volumes

### Quality Assurance
- **Measure Impact**: Compare result quality before and after reranking
- **User Feedback**: Collect feedback on result relevance and usefulness
- **Regular Review**: Periodically assess if Top K settings remain optimal
- **Context Matters**: Adjust Top K based on query complexity and domain

### Resource Management
- **Set Limits**: Establish resource usage limits for processing
- **Monitor Usage**: Track resource consumption across different Top K settings
- **Optimize Strategically**: Use higher Top K only where quality impact justifies resource usage
- **Consider Alternatives**: Evaluate if similar quality can be achieved with lower Top K

## Troubleshooting

<AccordionGroup>
  <Accordion icon="exclamation-triangle" title="Invalid Configuration Parameters">
    **Solution**: Verify that:
    - `topK` is a positive integer or null
    - Value is reasonable for your use case (typically 1-50)
    - Configuration follows the correct JSON structure
  </Accordion>
  
  <Accordion icon="ban" title="Poor Quality After Update">
    **Solution**: If reranking quality decreased:
    - Increase `topK` to include more diverse results
    - Check if retrieval input quality is sufficient
    - Monitor reranking scores and positions
    - Consider if the change was too aggressive
  </Accordion>
  
  <Accordion icon="clock" title="Slow Processing After Update">
    **Solution**: If processing is too slow:
    - Reduce `topK` to process fewer documents
    - Check LLM service performance
    - Monitor system resource usage
    - Consider if unlimited processing is necessary
  </Accordion>
  
  <Accordion icon="chart-line" title="Configuration Not Taking Effect">
    **Solution**: After updating configuration:
    - Re-run the flow to apply new settings
    - Check that the node status shows `updated: false`
    - Verify configuration was saved correctly
    - Allow time for reprocessing to complete
  </Accordion>
  
  <Accordion icon="chart-bar" title="High Resource Usage">
    **Solution**: For resource optimization:
    - Review `topK` settings across all reranking nodes
    - Monitor processing resource metrics
    - Consider reducing `topK` for less critical applications
    - Implement resource usage alerts and limits
  </Accordion>
</AccordionGroup>

## Next Steps

After updating reranking node configuration, you might want to:

<CardGroup cols={2}>
  <Card
    title="List Reranking Nodes"
    icon="list"
    href="/api-reference/flows/nodes/reranking/list"
  >
    View updated reranking node configurations and performance metrics
  </Card>
  <Card
    title="Run Flow"
    icon="play"
    href="/api-reference/flows/run"
  >
    Execute your flow with the new reranking configuration
  </Card>
  <Card
    title="Update Retrieval Nodes"
    icon="search"
    href="/api-reference/flows/nodes/retrieval/update"
  >
    Optimize retrieval settings to work better with reranking
  </Card>
  <Card
    title="Flow Overview"
    icon="diagram-project"
    href="/api-reference/flows/overview"
  >
    Learn about all available flow management endpoints
  </Card>
</CardGroup>
